## 当 30% 的代码都由 AI 写出来，全栈工程师的时间应该花在哪里？

做全栈做得够久，你会经历很多次工具范式的变革：
从模块化、TypeScript、React、SSR，到 serverless、设计系统。

但过去三年里，**没有任何东西比 AI 协作更彻底地重塑我的工作方式**。

最意外的是：

> **AI 写的代码越来越多，而我本人反而越来越累。**

后端的 Controller、Service、DTO、校验、日志……
前端的组件、布局、响应式、交互骨架、翻译、样式……
AI 都能写，而且写得非常快。

真正的拐点发生在我意识到：

> **现在最难的工作，不是写代码，而是验证 AI 写的代码是否“真的正确”。**

本文是我作为一个全栈开发者的真实思考，不是翻译，而是结合网页原文思想、前端实际体验和 AI 协作心得重新写出的原创文章。

---

## 1. 两种极端声音，全栈开发者常常夹在中间

在所有 AI 编程的讨论里，总有两个极端：

### ⚡「AI 太强了，十倍效率！」

“10 分钟搞定 20 个组件。”
“我几乎没敲键盘就把登录做完了。”

### ⚡「AI 很蠢，用它还拖累我」

“看着对，其实不对。”
“调 bug 的时间比我自己写还长。”

而事实上，两边都说的没错：

* **后端**：CRUD、分页、校验、模板化逻辑 → AI 简直是核弹
* **前端**：组件结构、布局、样式、图转代码 → AI 超稳定
* 但 AI 很容易在以下场景翻车：

  * 复杂业务逻辑
  * 多状态 UI
  * 历史包袱沉重的代码
  * 隐式规则多的老系统

我最开始用 AI 完全是试运气：

* 觉得“AI 应该能做吧”就丢给它
* 有时超预期
* 有时“优雅但致命”的 bug 让我怀疑人生

直到意识到：

> **不是 AI 随机，而是我的流程随机。**

---

## 2. 别再问「AI 准不准」，应该问「值不值」

我过去特别执着：

* “AI 生成的代码对不对？”
* “这个校验逻辑有没有漏？”
* “这个组件结构是不是最佳实践？”

但后来发现：

**准确率是一个会把人带沟里的指标。**

真正该算的是 ROI（投入产出比）：

```
价值 = 纯手写时间 ÷（AI 生成时间 + 人工修复时间）
```

如果手写要 6 小时
AI 生成 + 修改只用 1 小时
→ 那就是赚翻了

即使第一次生成不完美，只要能省时间，就是「值」。

### “AI 最划算的工作”四要素

无论前端还是后端，都高度一致：

1. **重复度高 / 模板化强**
2. **纯手写耗时长但没有创造性**
3. **风险低（做错不会导致系统爆炸）**
4. **结果容易验证**

这类任务，就是所谓的：

> **AI 的“甜点区”。**

---

## 3. 前端的革命：设计稿转代码已经不是梦想，而是默认能力

2024–2025 最大的前端革命来自：

> **Gemini 3 Pro 等模型的“设计稿还原”能力进化到了几乎像作弊的程度。**

我不是夸张。

给它：

* 一张 Figma 截图
* 一个完整设计稿
* 甚至是粗糙的 UI 草图

它都能稳定输出：

* React + TSX 组件
* Tailwind / CSS Modules
* 完整响应式布局
* 主题化变量
* 无障碍（ARIA）标注
* 动效占位
* 像素级视觉结构

一些场景甚至可以达到 **90%–100% 的还原度**。

比如：

* 导航栏
* 表单
* 卡片列表
* Dashboard
* 复杂的栅格布局
* 商品详情页
* 登陆 / 注册流

### 那前端工程师还干什么？

我们从“敲 CSS、拼布局”变成了：

### ✔ 验证交互

是否键盘可访问？
是否存在焦点陷阱？
动画是否自然？

### ✔ 验证逻辑

组件的所有状态是否覆盖？

* loading
* error
* empty
* offline
* stale

### ✔ 验证兼容性

Safari 下是否抖动？
移动端是否溢出？
SSR hydration 是否正常？

### ✔ 验证极端情况

长字符串？
高速点击？
网络抖动？

### ✔ 验证架构与可维护性

AI 不会帮你保证：

* props 设计是否合理
* 状态是否拆分正确
* 逻辑是否可以复用
* 组件是否符合团队规范
* 是否适配现有 design system

换句话说：

> **前端开发者不再“画界面”，
> 而是负责“审界面、校逻辑、控质量”。**

这和后端一样：从“写代码”变成“验代码”。

---

## 4. 全栈工程师的新角色：上下文设计师（Context Designer）

以前的全栈是：

* 写页面
* 写接口
* 写逻辑
* 写测试
* 修 bug

现在的全栈变成：

> **设计上下文 → 用 AI 生成 → 验证 → 整合 → 测试 → 监控**

### 我现在把 AI 当成一个「超强但没背景信息的实习生」

它很擅长：

* 模式化代码
* 风格统一
* 转换与重构
* 性能优化建议
* 跟示例学风格

但它不擅长：

* 理解业务全貌
* 历史包袱
* “哪些地方不能错”
* 系统隐形约束
* 异常链路的坑

所以我的时间配比从：

* **80% 写代码 / 20% 自测**
  变成
* **30% 指挥生成 / 70% 验证质量**

听起来更累？

没错，但也更接近“工程价值”的核心区域。

AI 写代码，
工程师管系统。

---

## 5. 让项目“AI 友好”：标准化 + 自动化

几乎所有团队都会遇到同一个悖论：

> **AI 用得越来越多，但效率没明显提升。**

原因很简单：

### **AI 在干净的工程体系里表现很好，在混乱的项目里表现极差。**

我在全栈项目里总结出的最佳做法：

### 后端标准化：

* OpenAPI / Proto 明确契约
* DTO / Error 统一格式
* 业务规则文档化
* 日志规范一致
* SQL / Prisma / Drizzle 内部规则统一

### 前端标准化：

* 统一 components / hooks / utils 目录
* 统一 spacing / color / typography token
* 明确组件命名规范
* 明确 props 设计原则
* 清晰的设计系统（tokens + primitives + patterns）

只要标准化做好：

> **AI 的命中率会呈非线性上涨。**

### 自动化把 AI 的价值再向上推一层

* pre-commit
* snapshot testing
* visual diff
* 类型测试
* e2e 流程回归
* Storybook 交互测试
* PR Bot 自动评论

现在全都能用 AI 辅助搭建。

AI 不只是写代码，更是写“工程体系”。

---

## 6. 为什么越来越多人说：AI 写代码越多，我越累？

这是当今工程师最真实的困境：

> **人类其实是一个“算力高但上下文窗口超小的 LLM”。**

AI 写得越快，人类要处理的东西越多：

* 更多 PR
* 更多生成物
* 更多决定
* 更多 review
* 更多上下文切换

注意力碎片化，才是真正让人累垮的原因。

### 我作为全栈的「自救方法」

* **深度工作分层**：一段时间只解决一个模块
* **AI 批处理**：统一写 prompt → 让 AI 批量跑 → 最后集中验收
* **3 分钟原则**：能马上解决的就立刻做
* **背景清晰**：所有 prompt 都带背景、目标、限制、验收标准
* **单日单主线**：一天只推进一个“大主题”

AI 放大了生产力，
也放大了注意力成本。

只有先管理注意力，才能真正享受 AI 的红利。

---

## 7. 两条不会随着模型迭代而过时的原则

### **原则一：瓶颈已从生成转移到验证**

生成只要 10 秒
验证可能要 1 小时

写代码不再是主力工作
**验证正确性** 才是工程师的核心价值

### **原则二：上下文是王道（Context is King）**

AI 的上限 = 你给它的上下文质量

最好的上下文来自：

* 明确的需求
* 成熟的模式
* 高质量示例
* 完整的结构化文档
* 统一的工程体系

---

## 8. 作为全栈开发者，我给不同阶段使用 AI 的同行一些建议

### 🌱 刚开始用 AI

从最容易的甜点区入手：

* CRUD
* 小组件
* 小脚本
* 本地工具类

先把「值不值」那条公式跑顺。

### 🌿 已经大量使用 AI

开始优化：

* 上下文
* 验证流程
* 项目结构
* 自动化体系

### 🌳 如果你是 Tech Lead 或 Manager

把注意力从：

**“AI 能写多少代码？”**
转向
**“我们的协作流程有多稳？”**

写代码只是一个环节
工程效率来自整个流水线的稳定和清晰

---

## 写在最后

AI 没有取代开发者——
它重塑的是开发者的角色边界。

我们不再是写代码的机器，
而是：

* 上下文的设计者
* 质量的守门人
* 系统的架构者
* AI 的调度者

AI 写代码，
但我们决定：

* 写什么
* 为什么写
* 是否正确
* 是否能上线
* 是否能长期维护

我们从“写代码”，
走向了：

> **“设计和验证一个能替你写代码的智能系统”。**
